\section{Design}

O design de sistemas de informação voltados à fiscalização cidadã deve conciliar requisitos aparentemente conflitantes: robustez suficiente para processar grandes volumes de dados governamentais, simplicidade operacional compatível com equipes reduzidas, e acessibilidade que permita ao cidadão comum compreender informações complexas. Conforme o paradigma de Design Science Research adotado neste trabalho \cite{hevner2004design}, as decisões de design devem ser orientadas tanto pela utilidade prática do artefato quanto pelo rigor teórico que fundamenta cada escolha.

Esta seção organiza as decisões técnicas em quatro dimensões interdependentes: a arquitetura de software que estrutura o sistema, o conjunto de tecnologias que a implementa, a estratégia de ingestão que alimenta a base de dados, e o modelo relacional que organiza as informações. Cada decisão é apresentada com suas alternativas consideradas e a justificativa para a escolha final, seguindo a tradição de documentação arquitetural proposta por Dragoni \textit{et al.} (\citeyear{dragoni2017microservices}).

\subsection{Arquitetura do Sistema}

A escolha arquitetural representa uma das decisões mais consequentes em projetos de software. Conforme já apresentado e justificado na Introdução, optou-se pela arquitetura de \textbf{monolito modular}. Esta abordagem combina a organização interna característica de microsserviços --- com fronteiras claras entre domínios de negócio --- com a simplicidade operacional necessária ao contexto acadêmico, eliminando a complexidade de orquestração distribuída.

\subsubsection{Organização em Módulos}

A estrutura interna segue os princípios de \textit{Bounded Contexts} do \textit{Domain-Driven Design} \cite{evans2003ddd}, onde cada módulo representa um contexto de domínio com responsabilidades claramente delimitadas. O diretório \texttt{internal/} organiza-se em cinco módulos principais, cada um encapsulando um aspecto da fiscalização parlamentar:

\begin{itemize}
    \item \texttt{internal/senador}: Gerencia dados cadastrais e mandatos históricos, atuando como ``fonte de verdade'' para identificação de parlamentares;
    \item \texttt{internal/ceaps}: Processa despesas da Cota Parlamentar, implementando detecção de anomalias e agregações por categoria;
    \item \texttt{internal/votacao}: Coleta votações nominais e calcula métricas como presença e fidelidade partidária;
    \item \texttt{internal/emenda}: Integra dados do Portal da Transparência, com tratamento especial para ``emendas PIX'';
    \item \texttt{internal/ranking}: Orquestra o cálculo de pontuações conforme metodologia definida na Seção~3.3.
\end{itemize}

Módulos transversais complementam a estrutura: \texttt{internal/api} expõe \textit{endpoints} REST, \texttt{internal/scheduler} gerencia tarefas agendadas, e \texttt{internal/cache} abstrai operações no \textit{Redis}. Os módulos comunicam-se exclusivamente através de interfaces \textit{Go}, respeitando o princípio de inversão de dependência.

\subsubsection{Visão de Implantação}

A Figura~\ref{fig:implantacao} apresenta a arquitetura de implantação do sistema, ilustrando o fluxo de dados desde as fontes governamentais até o usuário final. Tanto o \textit{back-end} quanto o \textit{front-end} são executados em contêineres no \textit{Google Cloud Run}, garantindo escalabilidade unificada. O \textit{back-end} consome dados armazenados em \textit{PostgreSQL} (\textit{Cloud SQL}) e \textit{Redis} (\textit{Memorystore}), enquanto o \textit{scheduler} opera como um módulo interno do serviço principal, aproveitando a mesma infraestrutura.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{imagens/arquitetura-implantacao.png}
    \caption{Arquitetura de implantação do sistema Tô De Olho}
    \label{fig:implantacao}
    \par\small{Fonte: Autoria Própria}
\end{figure}

\subsection{Stack Tecnológico}

A seleção de tecnologias foi orientada por três critérios: desempenho em cenários de alta concorrência (característicos de \textit{pipelines} de ingestão), manutenibilidade a longo prazo (considerando a natureza \textit{open-source} do projeto), e adequação ao domínio (priorizando ferramentas com suporte robusto a operações analíticas).

\subsubsection{\textit{Back-end} em \textit{Go}}

A linguagem \textit{Go} foi selecionada após avaliação comparativa com \textit{Node.js} e \textit{Python}. O fator decisivo foi o modelo de \textbf{\textit{goroutines}}: \textit{threads} leves gerenciadas pelo \textit{runtime}, consumindo aproximadamente 2KB de memória inicial --- em contraste com cerca de 1MB por \textit{thread} de sistema operacional \cite{nanz2015comparative}. Essa eficiência viabiliza o processamento paralelo de centenas de requisições \textit{HTTP} durante a ingestão.

O \textit{framework} \textbf{\textit{Gin}} foi escolhido por seu roteamento baseado em árvore de prefixos (\textit{radix tree}), com desempenho até 40 vezes superior a alternativas \cite{lie2024golang}. O \textit{ORM} \textbf{\textit{GORM}} oferece migrações automáticas e operações de \textit{upsert} essenciais para evitar duplicação de registros. Para ambientes de produção, o sistema implementa agrupamento de conexões (\textit{connection pooling}) com limites configuráveis de conexões ociosas e máximas.

\subsubsection{Camada de Persistência}

\textbf{\textit{PostgreSQL}} foi selecionado por sua robustez em consultas analíticas e suporte a \textit{CTEs} (\textit{Common Table Expressions}), essenciais para agregações complexas. Originado em 1986 na \textit{UC Berkeley} \cite{stonebraker1986postgres}, o banco garante conformidade \textit{ACID} crítica para operações de ingestão concorrente.

\textbf{\textit{Redis}} atua como \textit{cache} para listas pré-computadas, alcançando latências de 100--500 microssegundos por operação \cite{redis2024}. Esta camada evita recálculos custosos a cada requisição, materializando resultados após cada ciclo de sincronização.

\subsubsection{\textit{Front-end} em \textit{Next.js}}

A escolha de \textbf{\textit{Next.js} 16} justifica-se pela necessidade crítica de indexação por mecanismos de busca \cite{salim2024nextjs}. Diferentemente de \textit{SPAs} que renderizam conteúdo apenas via \textit{JavaScript}, \textit{Next.js} oferece renderização no servidor (\textit{Server-Side Rendering} - SSR) e geração estática (\textit{Static Site Generation} - SSG), entregando \textit{HTML} pré-renderizado aos robôs de indexação (\textit{crawlers}) --- requisito fundamental para plataformas de fiscalização que dependem de descoberta orgânica.

A biblioteca \textbf{\textit{Recharts}} foi selecionada para visualização de dados por sua integração declarativa com \textit{React}. \textbf{\textit{Tailwind CSS 4}} permite desenvolvimento ágil com classes utilitárias e geração otimizada de \textit{CSS} em produção \cite{tailwindcss2024}.

A escolha do \textbf{\textit{Bun}} como \textit{runtime JavaScript} fundamenta-se em estudos comparativos recentes que demonstram seu desempenho superior em operações síncronas e processamento \textit{JSON} \cite{smirnov2024bun}. Diferentemente do \textit{Node.js}, que utiliza o motor \textit{V8}, o \textit{Bun} é construído sobre o \textit{JavaScriptCore} (\textit{WebKit}), resultando em tempos de inicialização significativamente menores --- característica vantajosa para o ciclo de desenvolvimento iterativo. Além do \textit{runtime}, o \textit{Bun} incorpora gerenciador de pacotes nativo, eliminando dependências externas como \textit{npm} ou \textit{Yarn} e simplificando o \textit{pipeline} de \textit{build}.

\subsection{Estratégia de Ingestão de Dados}

A consolidação de dados dispersos em três \textit{APIs} governamentais representa um dos maiores desafios técnicos do projeto. O processo segue o paradigma \textit{Extract, Transform, Load} (\textit{ETL}), conforme Vassiliadis (\citeyear{vassiliadis2009survey}) tipicamente consome entre 60\% e 80\% do esforço total em projetos de \textit{data warehousing}.

A estratégia adotada combina duas abordagens complementares: \textbf{\textit{backfill}} para carga histórica inicial e \textbf{sincronização contínua} para manutenção incremental. Conforme Kimball e Ross (\citeyear{kimball2013toolkit}), operações de carga histórica devem privilegiar vazão (\textit{throughput}) sobre latência, utilizando arquivos \textit{CSV} consolidados e inserções em lote (\textit{bulk inserts}). As fontes históricas incluem \textit{CEAPS} (2008--2025, ~500 mil registros), votações (2019--presente) e emendas (2015--presente).

Para o módulo de emendas, o \textit{backfill} utiliza o \textit{CSV} consolidado do Portal da Transparência, com leitura \textit{streaming} e detecção automática de delimitador. Como a identificação do autor é textual, o processo aplica normalização de grafia (remoção de acentos, espaços e pontuação) para casar \textit{nomeAutor} com o cadastro de senadores. A idempotência é garantida por chave composta \texttt{(codigoEmenda, senador\_id, ano)}, com \textit{upsert} via \textit{ON CONFLICT}.

A sincronização contínua opera via \textit{polling} periódico, calibrado pela volatilidade de cada domínio: votações diárias às 03:00 \textit{BRT} (baixo tráfego nas \textit{APIs}), remunerações semanais aos domingos, e emendas mensalmente após fechamento contábil.

Para garantir consistência, o sistema opera sob modelo \textit{at-least-once} com \textbf{idempotência} via chaves naturais compostas \cite{hummer2013modeldriven}. Falhas transientes são tratadas com espera exponencial (\textit{exponential backoff}, $t_{wait} = base \times 2^{tentativa}$) conforme recomendação \textit{AWS} \cite{aws2015backoff}, tempo limite (\textit{timeout}) de 30 segundos e falha graciosa que permite continuidade da sincronização mesmo com fontes temporariamente indisponíveis.

\subsection{Modelo de Dados}

O modelo relacional constitui o alicerce sobre o qual todas as funcionalidades são construídas. O projeto priorizou dois objetivos: garantir integridade referencial durante ingestão concorrente, e otimizar consultas analíticas frequentes como agregações de gastos por senador, período e categoria.

A Figura~\ref{fig:er-diagram} apresenta o diagrama entidade-relacionamento.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.7\textwidth]{docs/diagrama_er_modelo.png}
\caption{Diagrama entidade-relacionamento do sistema Tô De Olho}
\label{fig:er-diagram}
\par\small{Fonte: Autoria Própria}
\end{figure}

As entidades organizam-se em torno de \textbf{Senador}, a entidade central identificada por código parlamentar único. Relacionamentos 1:N conectam o senador a: \textbf{Mandato} (legislatura, tipo, período), \textbf{Despesa CEAPS} (com chave composta para idempotência), \textbf{Votação} (tabela associativa com sessão), \textbf{Servidor de Gabinete} (nome, cargo, remuneração), \textbf{Emenda} (incluindo Transferências Especiais) e \textbf{Comissão Membro} (participação com cargo e período).

Para otimizar consultas frequentes, foram criados os seguintes índices compostos:

\begin{itemize}
    \item \texttt{idx\_despesa\_senador\_ano} --- totalização de gastos por período;
    \item \texttt{idx\_votacao\_sessao\_senador} --- cálculo de presença em votações;
    \item \texttt{idx\_emenda\_senador\_tipo} --- filtros por modalidade de emenda;
    \item \texttt{idx\_comissao\_senador} --- agregação de participação em comissões.
\end{itemize}
