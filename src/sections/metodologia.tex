\section{Metodologia}

O desenvolvimento do \textit{Tô De Olho} enquadra-se no paradigma da \textit{Design Science Research} (DSR), abordagem metodológica adequada para pesquisas que visam a construção e avaliação de artefatos tecnológicos destinados a resolver problemas organizacionais identificados \cite{hevner2004design}. O problema abordado --- a fragmentação de dados públicos sobre a atuação de senadores federais em múltiplas APIs governamentais não integradas --- demanda a construção de um artefato de software capaz de consolidar, processar e apresentar essas informações de forma acessível ao cidadão.

Esta seção detalha a abordagem de desenvolvimento iterativo adotada, as fontes de dados governamentais integradas, a arquitetura do sistema, a estratégia de ingestão via ETL, o algoritmo de ranking inspirado no \textit{Legislative Effectiveness Score} e a infraestrutura de implantação.

\subsection{Abordagem de Desenvolvimento}

A natureza do projeto --- integração de múltiplas APIs governamentais com estruturas de dados heterogêneas e documentação variável --- demandou uma abordagem de desenvolvimento capaz de acomodar descobertas incrementais e ajustes frequentes de escopo. Metodologias tradicionais de desenvolvimento em cascata, que pressupõem requisitos estáveis e bem definidos desde o início, mostraram-se inadequadas para este contexto de exploração de APIs públicas com comportamentos nem sempre previsíveis.

Optou-se, portanto, por uma abordagem \textbf{iterativa e incremental}, na qual o trabalho foi organizado em ciclos de desenvolvimento focados em entregas funcionais. Cada ciclo produzia um incremento utilizável do sistema, permitindo validação contínua das funcionalidades implementadas e ajustes baseados nos aprendizados obtidos durante a integração com cada API.

O desenvolvimento contou com apoio de ferramentas de inteligência artificial generativa como assistentes de codificação, seguindo a tendência contemporânea de \textit{AI-assisted software development} \cite{peng2023impact}. Tais ferramentas, baseadas em modelos de linguagem de grande escala (LLMs), foram empregadas para aceleração de tarefas como geração de código \textit{boilerplate}, refatoração e \textit{debugging}. A engenharia de contexto --- técnica de estruturação de informações para maximizar a qualidade das respostas do modelo --- foi aplicada através de arquivos de configuração que definem padrões de codificação, stack tecnológico e regras de negócio do projeto. A autoria e responsabilidade pelas decisões de arquitetura, design de algoritmos e validação de resultados permaneceram integralmente com o desenvolvedor.

A divisão do trabalho ocorreu em cinco fases principais:
\begin{enumerate}
    \item \textbf{Fundação}: Estruturação do projeto em Golang, implementação do cliente para a API Legislativa do Senado, criação das \textit{migrations} do banco de dados e configuração inicial do \textit{frontend} em Next.js;
    \item \textbf{Ingestão de Dados}: Implementação do cliente para a API Administrativa, configuração do \textit{scheduler} para tarefas agendadas, coleta de votações nominais e carga de dados históricos;
    \item \textbf{Ranking e API}: Desenvolvimento do serviço de cálculo de rankings, criação dos \textit{endpoints} REST para consumo pelo \textit{frontend}, configuração do cache Redis e implementação de testes automatizados;
    \item \textbf{Frontend}: Desenvolvimento do \textit{dashboard} principal, interface de ranking interativo e páginas de perfil dos senadores;
    \item \textbf{Emendas e Polimento}: Integração com o Portal da Transparência para dados de emendas parlamentares, visualizações de dados e preparação para \textit{deploy}.
\end{enumerate}

\subsection{Fontes de Dados}

O sistema integra três fontes de dados governamentais oficiais, fundamentadas no arcabouço legal brasileiro de transparência pública. A Lei de Acesso à Informação (Lei n. 12.527/2011) estabelece como diretriz a ``disponibilização de informações em formatos abertos, estruturados e legíveis por máquina'' \cite{lai2011}, princípio que as APIs governamentais operacionalizam. Conforme demonstrado pela Operação Serenata de Amor, tecnologias desenvolvidas sobre esses dados abertos podem gerar valor público ao facilitar o controle social do gasto parlamentar \cite{albuquerque2018serenata}.

A seleção dos \textit{endpoints} e campos consumidos seguiu três critérios: (i) \textbf{relevância para fiscalização cidadã} --- priorizando dados de gastos, votações e atuação legislativa; (ii) \textbf{disponibilidade e confiabilidade} --- selecionando fontes com documentação oficial e atualização regular; e (iii) \textbf{viabilidade técnica} --- considerando formatos estruturados (JSON/XML), autenticação simples e limites de requisição adequados.

\subsubsection{API Legislativa do Senado}

Documentada em \texttt{legis.senado.leg.br/dadosabertos}, esta API RESTful fornece dados do processo legislativo. A URL base para requisições é \texttt{https://legis.senado.leg.br/dadosabertos}. Os dados são retornados em formato JSON, com suporte a paginação e limite de 10 requisições por segundo.

\textbf{Endpoints de Senadores e Mandatos:}
\begin{itemize}
    \item \texttt{/dadosabertos/senador/lista/atual}: Lista de senadores em exercício, retornando código parlamentar, nome, foto, partido e UF;
    \item \texttt{/dadosabertos/senador/\{codigo\}}: Detalhes completos do senador, incluindo biografia, e-mail e telefone;
    \item \texttt{/dadosabertos/senador/\{codigo\}/mandatos}: Histórico de mandatos com legislatura, tipo e datas;
    \item \texttt{/dadosabertos/senador/\{codigo\}/licencas}: Licenças oficiais com motivo e período --- essencial para ajuste dos cálculos de presença.
\end{itemize}

\textbf{Endpoints de Votações:}
\begin{itemize}
    \item \texttt{/dadosabertos/votacao}: Votações nominais filtráveis por código do parlamentar, data e orientação de voto;
    \item \texttt{/dadosabertos/votacaoComissao/parlamentar/\{codigo\}}: Votações em comissões específicas;
    \item \texttt{/dadosabertos/plenario/votacao/orientacaoBancada/\{data\}}: Orientação partidária para cálculo de fidelidade.
\end{itemize}

\textbf{Endpoints de Atuação Legislativa:}
\begin{itemize}
    \item \texttt{/dadosabertos/processo?codigoParlamentarAutor=\{codigo\}}: Proposições de autoria do senador;
    \item \texttt{/dadosabertos/processo/relatoria?codigoParlamentar=\{codigo\}}: Relatorias designadas;
    \item \texttt{/dadosabertos/senador/\{codigo\}/comissoes}: Participação em comissões;
    \item \texttt{/dadosabertos/senador/\{codigo\}/discursos}: Discursos proferidos.
\end{itemize}

\subsubsection{API Administrativa do Senado}

Documentada em \texttt{adm.senado.gov.br/adm-dadosabertos/swagger-ui}, esta interface disponibiliza dados financeiros e administrativos. A URL base para requisições é \texttt{https://adm.senado.gov.br/adm-dadosabertos}.

\textbf{Cota Parlamentar (CEAPS):}
\begin{itemize}
    \item \texttt{/api/v1/senadores/despesas\_ceaps/\{ano\}}: Despesas da Cota para o Exercício da Atividade Parlamentar dos Senadores, retornando código do senador, tipo de despesa, fornecedor, CPF/CNPJ, valor reembolsado e mês.
\end{itemize}

\textbf{Estrutura e Benefícios:}
\begin{itemize}
    \item \texttt{/api/v1/senadores/auxilio-moradia}: Opção por auxílio-moradia;
    \item \texttt{/api/v1/senadores/escritorios}: Escritórios de apoio parlamentar.
\end{itemize}

\textbf{Servidores de Gabinete:}
\begin{itemize}
    \item \texttt{/api/v1/servidores/servidores}: Lista de servidores com filtros por lotação;
    \item \texttt{/api/v1/servidores/remuneracoes/\{ano\}/\{mes\}}: Folha de pagamento mensal, retornando remuneração básica e líquida;
    \item \texttt{/api/v1/servidores/lotacoes}: Mapeamento entre senador e gabinete.
\end{itemize}

\subsubsection{Portal da Transparência (CGU)}

A API do Portal da Transparência (\texttt{api.portaldatransparencia.gov.br}) fornece dados de emendas parlamentares e transferências federais. O acesso requer autenticação via chave de API no \textit{header} \texttt{chave-api-dados}.

\textbf{Endpoint Principal:}
\begin{itemize}
    \item \texttt{/api-de-dados/emendas}: Lista de emendas parlamentares com parâmetros de filtro: \texttt{ano} (ano fiscal), \texttt{nomeAutor} (nome do parlamentar), \texttt{tipoEmenda} (Individual, Bancada, Comissão, Relator ou \textbf{Transferência Especial}).
\end{itemize}

O filtro \texttt{tipoEmenda=Transferência Especial} permite identificar as chamadas ``emendas PIX'', modalidade de repasse que dispensa convênio. Os campos retornados incluem código da emenda, autor, localidade do gasto, função, subfunção e valores (empenhado, liquidado e pago).

\subsubsection{Limitações e Cobertura Temporal}

Cada fonte de dados apresenta limitações que impactam o escopo e a profundidade das análises possíveis:

\begin{itemize}
    \item \textbf{API Legislativa}: Votações nominais disponíveis apenas a partir de 2019 (legislatura 56); dados anteriores requerem consulta a arquivos históricos em formato XML. Limite de 10 requisições por segundo;
    \item \textbf{API Administrativa}: Despesas CEAPS disponíveis desde 2008 em CSV; API REST cobre apenas o ano corrente. Não há \textit{endpoint} para vincular servidores diretamente ao gabinete do senador --- essa associação requer cruzamento com a tabela de lotações;
    \item \textbf{Portal da Transparência}: Emendas disponíveis a partir de 2015. Busca por autor utiliza correspondência textual (nome), não código parlamentar, exigindo normalização de grafia. Limite de 300 requisições por minuto com autenticação via chave de API.
\end{itemize}

Essas restrições foram consideradas no desenho do sistema: dados históricos são carregados via arquivos CSV (backfill), enquanto a sincronização contínua utiliza as APIs REST com tratamento adequado de limites de requisição.

\subsection{Estratégia de Ingestão de Dados}

A ingestão de dados representa um dos maiores desafios técnicos do projeto: consolidar informações dispersas em três APIs governamentais distintas, cada uma com suas idiossincrasias, limites de requisição e formatos de resposta. A estratégia adotada segue o paradigma \textit{Extract, Transform, Load} (ETL) em uma abordagem híbrida que combina carga inicial massiva (\textit{backfill}) com atualização incremental contínua.

Conforme fundamentado teoricamente na Seção~\ref{sec:etl-fundamentacao}, o processo ETL tipicamente consome entre 60\% e 80\% do esforço de desenvolvimento em projetos de \textit{data warehousing} \cite{vassiliadis2009survey}. Essa proporção reflete a complexidade inerente à extração de dados de fontes heterogêneas e à necessidade de transformações para garantir consistência e qualidade. A presente seção detalha a implementação específica adotada no \textit{Tô De Olho}, conforme ilustrado na Tabela~\ref{tab:ingestao}.

\begin{table}[H]
\centering
\caption{Estratégias de ingestão de dados: Backfill vs. Sincronização Contínua}
\label{tab:ingestao}
\begin{tabular}{|l|p{5.5cm}|p{5.5cm}|}
\hline
\textbf{Característica} & \textbf{Backfill (Carga Inicial)} & \textbf{Sincronização Contínua} \\
\hline
\textbf{Objetivo} & Popular o banco com dados históricos & Manter dados atualizados \\
\hline
\textbf{Execução} & Uma única vez, no setup do sistema & Diariamente, via cron jobs \\
\hline
\textbf{Volume de dados} & Grande (anos de histórico) & Pequeno (delta diário) \\
\hline
\textbf{Tempo de execução} & Horas (processamento em lote) & Minutos (\textless 5 min) \\
\hline
\textbf{Fonte preferencial} & CSVs para download em massa & APIs REST incrementais \\
\hline
\textbf{Exemplo} & CEAPS 2019--2025 via CSV & Votações dos últimos 7 dias \\
\hline
\end{tabular}
\end{table}

\subsubsection{Backfill (Carga Histórica)}

A carga inicial (\textit{Backfill}) distingue-se fundamentalmente da sincronização diária pelo volume e pela estratégia de escrita. Conforme preceituado por Kimball e Ross \cite{kimball2013data}, operações de carga histórica devem privilegiar o \textit{throughput} (vazão) em detrimento da latência individual. Esta recomendação reflete décadas de experiência prática: tentar carregar milhões de registros através de inserções unitárias resulta em tempos de execução proibitivos e pressão desnecessária sobre as APIs de origem.

Para este projeto, optou-se pela estratégia de \textbf{Backfill em Lote Isolado}. Ao invés de reutilizar os \textit{endpoints} REST --- projetados para transações unitárias e limitados por \textit{rate limiting} rigoroso --- o sistema consome arquivos CSV consolidados disponibilizados pelas fontes primárias. Esta abordagem reduz o \textit{overhead} de rede e permite o uso de \texttt{COPY} ou \textit{bulk inserts} no banco de dados, operações que alcançam taxas de inserção na ordem de dezenas de milhares de registros por segundo, ordens de magnitude superiores a inserções linha a linha.

A distinção entre carga inicial e sincronização contínua não é meramente operacional, mas também arquitetural. O processo de \textit{backfill} executa em ambiente isolado, podendo utilizar conexões de banco com configurações agressivas (\textit{batch size} elevado, desativação temporária de índices não-essenciais) sem impactar a disponibilidade do sistema em produção. As fontes de dados para carga inicial incluem:
\begin{itemize}
    \item \textbf{CEAPS}: Arquivos CSV anuais (2008--2025) disponíveis via \textit{endpoint} de dados abertos estáticos do Senado, totalizando aproximadamente 500 mil registros de despesas;
    \item \textbf{Votações}: Iteração controlada na API Legislativa por ano/legislatura (2019--Presente), respeitando limites de 10 requisições por segundo;
    \item \textbf{Emendas}: \textit{Dump} consolidado do Portal da Transparência, com dados desde 2015.
\end{itemize}

\subsubsection{Sincronização Contínua (Change Data Capture)}

Uma vez que os dados históricos foram carregados, o desafio seguinte consiste em mantê-los atualizados de forma eficiente. Idealmente, as APIs governamentais ofereceriam mecanismos de \textit{push} --- como \textit{Webhooks} ou fluxos de eventos (\textit{Streaming}) --- permitindo que o sistema fosse notificado proativamente sobre mudanças. Entretanto, nenhuma das três fontes de dados integradas disponibiliza tais recursos, uma limitação comum em APIs governamentais brasileiras.

Diante dessa restrição, adotou-se o padrão de \textbf{Polling Periódico Inteligente}, no qual o sistema atua como agente ativo que consulta periodicamente as fontes em busca de alterações (\textit{Pull Model}). Embora menos eficiente que abordagens baseadas em eventos, o \textit{polling} oferece vantagens significativas para integração com sistemas legados: simplicidade de implementação, ausência de dependências de infraestrutura complexa (como \textit{message brokers}) e compatibilidade garantida com qualquer API que suporte requisições HTTP.

A periodicidade dos \textit{cron jobs} foi calibrada com base na \textbf{Janela de Consistência Eventual} aceitável para cada domínio de dado. O conceito de consistência eventual, originário de bancos de dados distribuídos, reconhece que em sistemas descentralizados, os dados podem estar temporariamente desatualizados desde que eventualmente convirjam para o estado correto. Para um portal de fiscalização cidadã, a precisão ao segundo não é necessária; o que importa é que os dados reflitam a realidade em um horizonte razoável:

\begin{itemize}
    \item \textbf{Alta Volatilidade (Diário)}: Status de senadores, presença e votações do dia anterior. A execução ocorre às 03:00 (horário de Brasília), período de baixa atividade nos servidores governamentais, capturando o fechamento completo do dia legislativo;
    \item \textbf{Média Volatilidade (Semanal)}: Remuneração de servidores e mapeamento de lotações. A folha de pagamento do Senado é atualizada mensalmente, mas a execução semanal (domingos às 04:00) garante margem de segurança para capturar eventuais correções;
    \item \textbf{Baixa Volatilidade (Mensal)}: Consolidação de emendas parlamentares. Os dados de execução orçamentária do Portal da Transparência são consolidados mensalmente, justificando a execução no dia 05 de cada mês, após o fechamento contábil público.
\end{itemize}

Esta estratégia de \textit{polling} respeita os princípios de ``Cidadania de API'' (\textit{API Good Citizenship}), concentrando requisições em horários de baixo tráfego para minimizar impacto nos servidores governamentais e maximizar a taxa de sucesso das chamadas.

\subsubsection{Idempotência e Consistência Eventual}

Em sistemas distribuídos sujeitos a falhas de rede, a garantia de entrega \textit{exactly-once} é virtualmente impossível de alcançar na prática \cite{hummer2013modeldriven}. Qualquer comunicação entre componentes pode falhar após o processamento mas antes da confirmação, deixando o cliente em estado de incerteza. Portanto, o sistema foi projetado para operar sob o modelo \textit{at-least-once}, no qual operações podem ser repetidas sem efeitos colaterais indesejados, apoiado pela propriedade de \textbf{Idempotência}.

Matematicamente, uma operação de ingestão $f(x)$ é idempotente se $f(f(x)) = f(x)$. Ou seja, aplicar a função múltiplas vezes produz o mesmo resultado que aplicá-la uma única vez. Esta propriedade, originária da álgebra abstrata, encontra aplicação direta em operações de banco de dados: uma inserção \texttt{INSERT OR UPDATE} (\textit{upsert}) com chave primária definida é idempotente, pois tentativas subsequentes simplesmente sobrescrevem o registro existente com valores idênticos.

A implementação de idempotência no \textit{Tô De Olho} utiliza chaves naturais compostas (\textit{Composite Natural Keys}) em vez de identificadores gerados. Esta escolha reflete uma decisão arquitetural deliberada: os sistemas de origem (APIs do Senado e Portal da Transparência) são a fonte de verdade para identificação de entidades. As operações de \textit{upsert} garantem:
\begin{itemize}
    \item \textbf{Despesas CEAPS}: Unicidade garantida pela tupla \texttt{(senador\_id, fornecedor\_cnpj, data\_emissao, valor\_centavos)}. Esta combinação identifica univocamente cada reembolso, considerando que o mesmo senador não pode receber dois reembolsos idênticos do mesmo fornecedor no mesmo dia;
    \item \textbf{Votações}: Unicidade via \texttt{(id\_sessao, id\_parlamentar)}. Cada senador registra no máximo um voto por sessão de votação;
    \item \textbf{Emendas}: Unicidade via \texttt{(codigo\_emenda, autor, ano)}. O código de emenda é único por autor e ano fiscal.
\end{itemize}

Essa abordagem elimina a necessidade de gerenciamento de estado complexo no \textit{pipeline} de ingestão: em caso de dúvida, falha de rede ou interrupção inesperada, o sistema pode simplesmente reprocessar o lote inteiro, garantindo convergência para o estado correto sem risco de duplicação de dados.

\subsubsection{Resiliência e Tratamento de Erros}

A integração com APIs governamentais apresenta desafios de estabilidade: diferentemente de serviços comerciais com \textit{SLAs} bem definidos, as APIs públicas brasileiras operam sem garantias formais de disponibilidade. Para lidar com falhas transientes, o sistema implementa mecanismos simples e eficazes:

\begin{itemize}
    \item \textbf{Retry com Backoff Exponencial}: Para erros de rede ou respostas 5xx, o sistema aguarda progressivamente mais tempo entre tentativas. A fórmula segue o padrão recomendado pela AWS \cite{aws2015backoff}: $t_{wait} = base \times 2^{tentativa}$, com $base = 1s$ e máximo de 3 tentativas. Esta abordagem evita sobrecarregar APIs temporariamente indisponíveis;
    
    \item \textbf{Timeout Configurável}: Cada requisição possui timeout de 30 segundos, evitando que conexões travadas bloqueiem o processo de ingestão;
    
    \item \textbf{Falha Graciosa}: Quando uma fonte de dados está indisponível, o job registra o erro e prossegue com as demais fontes. Jobs que falham são marcados para reexecução manual.
\end{itemize}

Para cenários de produção com maior volume de requisições, padrões como \textit{Circuit Breaker} \cite{nygard2018release} poderiam ser adicionados para isolar falhas em cascata. Entretanto, dado o escopo do MVP --- com execuções diárias em horário de baixo tráfego --- a estratégia de retry simples atende adequadamente às necessidades.

\subsubsection{Logs e Monitoramento}

O monitoramento do \textit{pipeline} de ingestão adota uma abordagem pragmática, adequada ao escopo do projeto:

\begin{itemize}
    \item \textbf{Logs Estruturados}: Todos os eventos de ingestão são emitidos em formato JSON, contendo: identificador do job, fonte de dados, duração, quantidade de registros processados e eventual mensagem de erro. Esta estruturação facilita a análise posterior e permite identificar rapidamente a causa de falhas;
    
    \item \textbf{Endpoint de Health}: O sistema expõe um \textit{endpoint} \texttt{/health} que retorna o status da última sincronização de cada fonte, permitindo verificar se os dados estão atualizados.
\end{itemize}

Para evolução futura, a literatura recomenda a adoção dos três pilares da observabilidade --- logs, métricas e traces \cite{sridharan2018observability}. Ferramentas como Prometheus (métricas) e Jaeger (tracing distribuído) poderiam ser integradas conforme a complexidade operacional aumentar.

\subsection{Arquitetura do Sistema}


O \textit{Tô De Olho} adota uma arquitetura de \textbf{monolito modular}, na qual os componentes são organizados internamente em módulos bem definidos, mas compartilham um único processo de \textit{deploy}. A escolha foi motivada por:

\begin{itemize}
    \item \textbf{Simplicidade Operacional}: Um único contêiner simplifica a infraestrutura de implantação e monitoramento;
    \item \textbf{Compartilhamento de Recursos}: Conexão única com banco de dados, eliminando latência de rede entre serviços e reduzindo o consumo de memória;
    \item \textbf{Definição de Fronteiras do Domínio}: Conforme argumentado por Martin Fowler em sua defesa da estratégia \textit{MonolithFirst} \cite{fowler2015monolith}, iniciar com um monolito permite compreender melhor os limites naturais do domínio antes de incorrer no custo de complexidade de sistemas distribuídos;
    \item \textbf{Modularidade e Evolução}: A arquitetura segue o padrão de Monolito Modular, recentemente formalizado na literatura como uma alternativa viável que combina a simplicidade do monolito com a manutenibilidade dos microsserviços \cite{su2024modular}. A estrutura interna desacoplada facilita uma eventual migração futura para serviços independentes apenas onde for estritamente necessário.
\end{itemize}

\textbf{Módulos Internos:}
\begin{itemize}
    \item \texttt{internal/senador}: Gerencia dados cadastrais dos parlamentares e mandatos;
    \item \texttt{internal/ceaps}: Processa e totaliza despesas da Cota Parlamentar;
    \item \texttt{internal/emenda}: Integra dados de emendas e transferências do Portal da Transparência;
    \item \texttt{internal/votacao}: Coleta e armazena votações nominais;
    \item \texttt{internal/ranking}: Orquestra o cálculo de scores e agregações.
\end{itemize}

Os módulos comunicam-se através de chamadas de função diretas, simplificando o fluxo de dados. Para operações de ingestão, utilizam-se \textit{goroutines} para processamento concorrente.

\subsection{Stack Tecnológico}

A escolha das tecnologias foi orientada por critérios de desempenho, manutenibilidade e adequação ao domínio do problema. A seguir, justificamos cada escolha com base em literatura técnica.

\textbf{Backend --- Golang:}

A linguagem Go foi selecionada para o \textit{backend} após avaliação de alternativas como Node.js e Python. O fator decisivo foi o modelo de \textbf{concorrência nativo}: as \textit{goroutines} são threads leves gerenciadas pelo runtime Go, consumindo aproximadamente 2KB de memória inicial --- em contraste com threads do sistema operacional que utilizam cerca de 1MB cada \cite{nanz2015comparative}. Essa eficiência permite processar centenas de milhares de conexões simultâneas, característica essencial para a ingestão paralela de dados de três APIs distintas.

O framework \textbf{Gin} foi escolhido por seu roteamento HTTP baseado em \textit{radix tree}, reportando desempenho até 40 vezes superior a frameworks anteriores \cite{alfian2024gin}. \textbf{GORM} oferece mapeamento objeto-relacional com suporte a migrações automáticas.

\textbf{Banco de Dados --- PostgreSQL e Redis:}

\textbf{PostgreSQL} foi selecionado como banco relacional por sua robustez em consultas analíticas e suporte a índices compostos, essenciais para agregações por senador, período e tipo de despesa. Originado em 1986 na Universidade da Califórnia, Berkeley \cite{stonebraker1986postgres}, sua conformidade ACID garante integridade nas operações de ingestão.

\textbf{Redis} atua como camada de cache para rankings pré-computados e totalizadores de gastos. Por armazenar dados inteiramente em memória RAM, Redis alcança latências típicas entre 100 e 500 microssegundos \cite{redis2024}, eliminando a necessidade de recalcular métricas a cada requisição.

\textbf{Frontend --- Next.js 15:}

A escolha de \textbf{Next.js} sobre React ``puro'' justifica-se pela necessidade de \textbf{SEO} e performance inicial \cite{salim2024nextjs}. Next.js resolve o problema de indexação com \textit{Server-Side Rendering} (SSR) e \textit{Static Site Generation} (SSG), entregando HTML pré-renderizado aos \textit{crawlers}.

A biblioteca \textbf{Recharts} foi selecionada para visualização de dados por sua integração nativa com React \cite{recharts2024}. \textbf{Tailwind CSS} permite estilização eficiente com classes utilitárias; a partir da versão 4, o modo \textit{Just-In-Time} (JIT) gera apenas o CSS utilizado \cite{tailwindcss2024}.

\subsection{Modelo de Dados}

O modelo relacional foi projetado para garantir integridade referencial e eficiência em consultas analíticas. As entidades principais e seus relacionamentos são:

\begin{itemize}
    \item \textbf{Senador}: Entidade central com código parlamentar único, nome, partido, UF e URL da foto;
    \item \textbf{Mandato}: Relacionamento 1:N com Senador, registrando legislatura, tipo e período;
    \item \textbf{Votação}: Relacionamento N:M entre Senador e Sessão, armazenando voto individual e orientação partidária;
    \item \textbf{Despesa CEAPS}: Relacionamento 1:N com Senador, contendo ano, mês, tipo de despesa, fornecedor, CPF/CNPJ e valor;
    \item \textbf{Servidor de Gabinete}: Relacionamento 1:N com Senador, registrando nome, cargo, vínculo e remuneração;
    \item \textbf{Emenda}: Relacionamento 1:N com Senador, contendo ano, tipo, localidade e valores (empenhado e pago).
\end{itemize}

Índices compostos foram criados nas colunas de consulta frequente: \texttt{(senador\_id, ano)} para despesas e emendas, e \texttt{(sessao\_id, senador\_id)} para votações.

\subsection{Algoritmo de Ranking}

O cálculo do \textit{score} de cada senador é inspirado no \textit{Legislative Effectiveness Score} (LES), metodologia desenvolvida por Volden e Wiseman para avaliar a efetividade legislativa de parlamentares americanos \cite{volden2018legislative}. A adaptação para o contexto brasileiro considerou as especificidades do Senado Federal e a disponibilidade de dados via API.

\subsubsection{Fundamentação Teórica}

O LES original define efetividade legislativa como ``a capacidade comprovada de avançar itens da agenda de um parlamentar através do processo legislativo até sua transformação em lei'' \cite{volden2014lawmakers}. A metodologia utiliza uma matriz de 5 estágios de tramitação por 3 tipos de proposição, resultando em 15 indicadores ponderados.

Para a adaptação brasileira, manteve-se a filosofia de valorizar o avanço de proposições através do processo legislativo, incorporando critérios adicionais relevantes ao contexto de fiscalização cidadã: presença em votações, economia na cota parlamentar e participação em comissões.

\subsubsection{Critérios e Pesos}

O índice compõe-se de quatro critérios objetivos, cujos pesos refletem sua importância relativa para a avaliação de desempenho parlamentar:

\begin{table}[H]
\centering
\caption{Critérios do algoritmo de ranking}
\label{tab:criterios}
\begin{tabular}{|l|c|l|}
\hline
\textbf{Critério} & \textbf{Peso} & \textbf{Justificativa} \\
\hline
Produtividade Legislativa & 35\% & Core do LES: capacidade de aprovar proposições \\
Presença em Votações & 25\% & Compromisso efetivo com o mandato \\
Economia na Cota (CEAPS) & 20\% & Responsabilidade fiscal \\
Participação em Comissões & 20\% & Trabalho técnico especializado \\
\hline
\end{tabular}
\end{table}

\subsubsection{Produtividade Legislativa}

Este critério avalia o avanço de proposições de autoria do senador através do processo legislativo, atribuindo pontuação crescente por estágio alcançado:

\begin{table}[H]
\centering
\caption{Pontuação por estágio de tramitação}
\label{tab:estagios}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Estágio} & \textbf{Pontos} & \textbf{Mult. PEC} & \textbf{Mult. PLP} \\
\hline
Apresentado & 1 & $\times$3.0 & $\times$2.0 \\
Em Comissão & 2 & $\times$3.0 & $\times$2.0 \\
Aprovado em Comissão & 4 & $\times$3.0 & $\times$2.0 \\
Aprovado em Plenário & 8 & $\times$3.0 & $\times$2.0 \\
Transformado em Lei & 16 & $\times$3.0 & $\times$2.0 \\
\hline
\end{tabular}
\end{table}

Os multiplicadores refletem a maior complexidade de Propostas de Emenda Constitucional (PEC), que exigem quórum qualificado de 3/5 em duas votações, e Projetos de Lei Complementar (PLP), que requerem maioria absoluta. Projetos de Lei Ordinária (PL) utilizam o multiplicador base ($\times$1.0). Requerimentos e moções, por seu menor impacto legislativo, recebem multiplicador reduzido ($\times$0.5).

\textbf{Bônus de Relatoria}: Senadores que atuam como relatores recebem pontuação adicional: +4 pontos para relatoria de PEC, +2 pontos para PLP ou PL, e +1 ponto para relatoria em comissão permanente.

\subsubsection{Presença em Votações}

Calculada como a razão entre votações participadas e votações disponíveis:

\begin{equation}
\text{Presença} = \frac{\text{Votações Participadas}}{\text{Votações Disponíveis}} \times 100
\end{equation}

As votações disponíveis excluem períodos de licença oficial (médica ou para cargo executivo), garantindo que afastamentos justificados não penalizem o senador. Obstrução \textbf{não} conta como presença.

\subsubsection{Economia na Cota Parlamentar}

Calculada como a proporção não utilizada do teto da CEAPS:

\begin{equation}
\text{Economia} = \left(1 - \frac{\text{Gasto Senador}}{\text{Teto CEAPS}}\right) \times 100
\end{equation}

O teto da CEAPS varia por UF (R\$ 26.000 para DF até R\$ 44.000+ para estados da região Norte). Senadores com gasto acima de 120\% do teto recebem pontuação zero neste critério.

\subsubsection{Participação em Comissões}

Pontuação atribuída conforme o nível de engajamento:

\begin{itemize}
    \item Membro titular de comissão permanente: +2 pontos por comissão;
    \item Membro suplente: +1 ponto por comissão;
    \item Vice-presidente de comissão: +3 pontos;
    \item Presidente de comissão: +5 pontos;
    \item Membro de comissão temporária ou CPI: +1 ponto.
\end{itemize}

Comissões estratégicas recebem multiplicador adicional: CAE (Assuntos Econômicos) e CCJ (Constituição e Justiça) aplicam $\times$1.5, enquanto CAS (Assuntos Sociais) e CI (Infraestrutura) aplicam $\times$1.2.

\subsubsection{Fórmula Final}

Cada métrica é normalizada de 0 a 100 antes da ponderação. O \textit{score} final é calculado por:

\begin{equation}
Score = (\text{Produtividade} \times 0.35) + (\text{Presença} \times 0.25) + (\text{Economia} \times 0.20) + (\text{Comissões} \times 0.20)
\end{equation}

\subsubsection{Tratamento de Casos Especiais}

\begin{itemize}
    \item \textbf{Senadores novos (suplentes)}: Período mínimo de 30 dias para entrar no ranking, com \textit{badge} ``Novo'' por 6 meses;
    \item \textbf{Licença curta (\textless 30 dias)}: Mantido no ranking com ajuste nos denominadores;
    \item \textbf{Licença longa (\textgreater 30 dias)}: Exibido com \textit{badge} ``Licenciado'' e \textit{score} congelado;
    \item \textbf{Dados indisponíveis}: Critério afetado recebe peso zero; demais critérios são reponderados proporcionalmente.
\end{itemize}

\subsection{Infraestrutura e Implantação}

Todos os componentes são containerizados com Docker, utilizando \textit{multi-stage builds} para otimização das imagens. A implantação ocorre via Google Cloud Run, que oferece escala automática (inclusive a zero) e \textit{deploy} simplificado.

O \textit{pipeline} de CI/CD, implementado com GitHub Actions, automatiza as etapas:
\begin{enumerate}
    \item \textbf{Build}: Compilação dos binários Go e verificação de erros;
    \item \textbf{Test}: Execução de testes unitários e de integração com \textit{testcontainers};
    \item \textbf{Publish}: Construção da imagem Docker e envio para o Google Container Registry;
    \item \textbf{Deploy}: Atualização automática do serviço no Cloud Run.
\end{enumerate}

